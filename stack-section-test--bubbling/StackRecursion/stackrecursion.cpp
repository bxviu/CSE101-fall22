// Filename: stackrecursion.cpp
//
// The file basically contains a number of string functions that are "fundamentally" (or naturally) recursive,
// but are implemented with a stack.
// 
// The functions are: generating all stretches, generating all anagrams, generating the language from a string.
// For details about these functions, refer to the file stackrecursion_qns.pdf.
// 
// Each of these functions returns a list of strings. The main code only calls one of these functions,
// and the remaining calls are commented out. You can uncomment the function you want.
// Finally, the code sorts the list by lexicographic order, and prints the strings to the output file (each in a separate line).
// 
// The code uses the List data structure used in a number of CSE101 assignments and tests.
// 
// USAGE:  (the executable is generated by a Makefile)
//     ./stackrecursion <INPUT FILE> <OUTPUT FILE>
// 
//     The first line of <INPUT FILE> is read, as a string. The second line is optionally read as an int, if the desired
// function (language, stretch) requires an int argument. Again, all of this is hardcoded, so you need to comment/uncomment
// the desired lines to run different functions. <OUTPUT FILE> contains all subsequences, each in a separate line.
// 
// 
// C. Seshadhri, Jan 2020, Oct 2020

#include <iostream>
#include "list.h"
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector> 
#include <algorithm>
#include <sstream>
using namespace std;


// This class keeps pairs of string. This is useful for simulating the recursion through as stack.
class Pair
{
    public:
        string in_str;
        int pos;
        bool swap;
};       

// This function generates all bubblines of the input in_str, and outputs them as a list. This function does not use recursion.
// Input: string in_str
// Output: list of all bubblings of in_str

List allBubblings(string in_str)
{
    // IMPLEMENT THIS FUNCTION
    List final_list;
    stack<Pair> recurStack; 
    Pair init, stacktop;
    init.in_str = in_str;
    init.swap = false;
    init.pos = -1;
    recurStack.push(init);

    while (!recurStack.empty()) {
        stacktop = recurStack.top();
        recurStack.pop();
        if (stacktop.pos == (int)stacktop.in_str.length()-1) {
            if (stacktop.swap) final_list.insert(stacktop.in_str);
            continue;
        }
        Pair to_push;
        to_push.in_str = stacktop.in_str;
        to_push.pos = stacktop.pos;
        if (stacktop.swap) {
            to_push.in_str = stacktop.in_str.substr(0,stacktop.pos) + stacktop.in_str.substr(stacktop.pos + 1, 1) + stacktop.in_str.substr(stacktop.pos, 1) + stacktop.in_str.substr(stacktop.pos + 2);
        }
        to_push.pos++;
        to_push.swap = false;
        recurStack.push(to_push);
        to_push.swap = true;
        recurStack.push(to_push);
    }
    return final_list;
}


int main(int argc, char** argv)
{
    if (argc < 3) // must provide two arguments as input
    {
        throw std::invalid_argument("Usage: ./hello <INPUT FILE> <OUTPUT FILE>"); // throw error
    }

    ifstream input; // stream for input file
    ofstream output; // stream for output file

    input.open(argv[1]); // open input file
    output.open(argv[2]); // open output file

    string in_str, len_str; // to store the input string from the file

    getline(input, in_str); // get the single string from the input file

    List myList = allBubblings(in_str); // getting all bubblings into the linked list

    myList.sort(); // sort the list
    
    output << myList.print("\n") << endl;  // print the list, using a new line as delimiter between items of the list
    
    myList.deleteList(); // free all the memory of this list

    input.close(); // close the I/O files
    output.close();
}
